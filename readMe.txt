2022-07-27
1.主要是要完成api的功能
2.考虑到有一部分是需要串口与单片机通信，所以增加了server端，用于接收api给单片机发送的数据，然后由server控制的串口发送到单片机
3.交叉编译时 make CROSS_COMPILE=aarch64-linux-gnu-
4.不需要交叉编译时，直接make
5.使用open，write函数之后，好像不支持动态库的方式编译,导致编译动态库的时候，直接指定c文件



2022-07-28
1.makefile的结构做了一些小的调整，但是仍然有点问题，就是不会进入到目录中进行编译，即使目录中的文件被修改了。
2.基于1的问题，建议每一次都是make clean and make
3.一定要记得cp libdrvapi22134.so /usr/lib 不然没有更新库，就会比较尴尬！！
4.完成了msgq的链路，和cpu与单片机的串口通信。
5.目前单片机与cpu的通信是固定4字节，包括1个字节的帧头（0xa5），2个数据字节和一个校验和（前3个字节累加）。
6.由于之前定义了按键的数据发送，这次更新的通信主要是cpu发往单片机的控制（led控制，led状态）。第一个字节的数据从50（十进制）开始，用于表示通信的命令，第二个字节表示命令带的参数。
7.单片机收到数据后，需要做出应答，包括数据值的返回。第一个字节仍然是命令，第二个字节是0（一般，表示成功），或者小于254，255表示出错。
8 msgq，由于只有一个队列，所以使用不同的type来区分是发给api的还是server的。server的接收type定义为678，api的接收是234，可能还会加上命令，这样用于区分服务器给哪一条命令做出的应答。
9.由于单片机没法控制lcd屏幕的开启和关闭，程序已经调整为对于pwm的调整，关闭屏幕实际是pwm调整为0.开启时调整为200



2022-08-01
1. 使用iic的方式直接控制声卡，取消了mixer的方法，mixer方法没法获取某些寄存器的值，就统一改为iic的方式。
2.还没有进行功能验证测试，运行了一下没有什么问题。


2022-08-02
1.增加了rtc的接口部分
2.还在进一步完善中。



2022-08-08
1. 增加对多次运行的限制，server程序和api程序不允许多次运行，一次只能运行一个实体
2. server修改为守护进程，log日志需要使用绝对路径。

2022-08-09 11.30am
1. 对于防止api的库被多个程序使用的情况，修改了防止多次运行的方法，由服务程序记录pid，程序启动时将查询该pid是否退出，如果没有，则第二次运行API库的程序结束运行。
2.log日志采用alram 30的方法进行定时刷新磁盘记录，有利于系统出现错误时信息的保存。
3.服务程序调整为守护进程，日志目录调整为/root/log
4.正常情况，服务程序应该由系统启动时自动运行，写到/etc/rc.local文件中，考虑到非正常情况下，api启动时，会查看服务程序是否存在，不存在，则尝试启动服务程序。（这里要求服务程序名称不得被修改）
5.API程序启动服务程序时，改为自己fork和execl，主要是因为system会调用sh然后再fork子进程，这样导致查询服务程序时出现问题，调整为自己实现。

2022-08-09 16.56
1.更新makefile规则
2.使用子目录，各自生成build-in.o文件，最后再合成起来
3.目前还是有问题，就是子目录中文件被修改，make的时候不能识别到修改，需要make clean之后才能重新make


2022-08-10 11.30am
1.更新makefile，更加有效的编译，已经解决昨天子目录文件修改后不能编译的问题
2.解决编译过程中的警告问题



2022-08-10 17.36
1. 优化串口接收处理部分，去掉队列，出队入队操作。
2. 分离uinput设备的操作部分。



2022-08-12 16.00
1.继续完善接口函数，完成了看门狗的接口，核心板复位，lcd复位等的控制接口（都需要与单片机通信）。


2022-08-16 11.00am
1. 这一次更新PTT引脚的处理（需要更新内核，dts中handptt引脚进行了修改GPIO2_B4 -> GPIO2_B0）
2. keyboard.c进行了一些调整，因为需要打开两个event文件（并且之前的串口按键event中有一个ptt的按键（键值25），也需要进行回调函数的处理）
3. 对目录的命名进行了一些调整，后缀api表示只与API的库有关，server表示与后台服务程序有关，msgq与api和server都相关。这样能够更清晰的去对应代码
4. 由于PTT引脚的变化，需要控制单片机引脚（MIC_CTRL）的变化(与PTT引脚电平相反)，所以还增加了串口命令，当PTT引脚变化时，发送指令给单片机。
5. 本次更新需要更新内核，单片机以及本程序包。

2022-09-15
1.对音频音量调节进行了部分代码的限制，防止控制出现失调。
2.修改了程序的名称，程序内部的程序名也调整了。


2022-09-23
1. 对my_log.c进行了代码bug的修复，并增加注释



2022-10-07
1.server端增加了启动选项-D，运行时，使用这个选项进入调试模式，不会成为守护进程，也不会开启日志记录。增加了一些打印信息。
2.优化了server端的重复启动检测程序。
3.server端启动时，设置了es8388的音频控制，让扬声器通道的音量开启较大。（使用IIC的方法）
4.反复启动测试，目前测试均正常。
./drv722_22134_server running,Buildtime :Oct  7 2022 16:47:50
./drv722test running,Buildtime Buildtime :Oct  7 2022 14:45:43
drvCoreBoardInit running,Buildtime Buildtime :Oct  7 2022 16:47:50



2022-10-08
1. 优化test目录中测试程序，使用中文菜单提示模式。
2. 调整了msgq的入口参数判断，对空指针进行错误判断。


2022-10-09
1.联合客户排查调用api时出现的段错误，发现我的库函数和他的代码中出现同名函数，是因为调用他的同名函数引发的段错误。
2.修改msgq的api函数名，去除同名函数的问题。
3.完成test中文菜单提示的修改和测试。目前运行正常。


2022-10-10
1.test设置中led亮度bug修改


2022-12-19，适应原理图V1.4
1.对iic的函数进行了调整，取消了全局的文件描述符，但是仍然有些不能适应多个iic设备的初始化。
2.增加了一些其他接口，如LSPK，V12_CTRL,lcd_type等接口。
3.lcd_type调整为单片机获取，3399使用串口命令获取该参数。
4.mic_ctrl不再自动控制，改为提供给API控制。
5.键盘灯的闪烁控制，单独增加了一个API接口，单片机本身使用定时器实现
6.屏幕关闭的接口重新做了修改，5寸屏有一个单片机控制的LCD背光使能引脚，所以控制做了调整。
7.api指令使用了线程池，但是出现了一个bug，多个指令在跑的时候，可能出现有的串口指令返回快，有的串口指令返回慢，
   数据收到时，出现了线程交叉识别返回数据，导致两个线程都识别到了对方的指令，而造成了都是返回失败。
   解决这个问题，重新加入了一个串口内部消息队列，让线程单独等待自己需要的消息。
   要么就要取消线程池。
8.还需要做一个多线程程序验证程序验证可靠性。
9.使用多线程收发的时候，出现3399串口写卡死的情况，重启3399时（此时单片机没有重启），uboot也没法发送数据了，必须重新断电后才能使用串口。
	（重启之前）3399串口接收还能正常，此时单片机的按键还能正常的发送到3399的drv722test的程序中。单片机的程序似乎还正常，调试串口正常，按键能上报，led正常闪烁。
	给发送的函数加了线程互斥锁，还要测试看能否正常使用。


2022-12-20，适应原理图V1.4
1.多线程卡死的问题，在单片机端，使用示波器看到3399的串口仍在发送数据。单片机使用调试模式之后，程序又能继续正常进行。


2022-12-21，适应原理图V1.4
1.20号的问题是单片机接收数据时的bug，已经在单片机端修正了。
2.8388的初始化设置与alsamixer 有关，用这个命令可以调整初始值，而且开机时也保存着，但是不知道配置文件在哪个目录。
之后可以继续追查一下。


